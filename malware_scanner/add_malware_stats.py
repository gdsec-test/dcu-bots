import ast
import json
import logging
import os
import re
from datetime import datetime, timedelta
from logging.config import dictConfig
from ssl import create_default_context

import requests
import yaml
from pika import (BlockingConnection, SSLOptions, connection, credentials,
                  exceptions)
from settings import config_by_name


class Publisher:
    EXCHANGE = 'malware-stats'
    TYPE = 'direct'
    ROUTING_KEY = 'malware-stats'

    def __init__(self, _host, _port, _virtual_host, _username, _password):
        """
        :param _host:
        :param _port:
        :param _virtual_host:
        :param _username:
        :param _password:
        :return: None
        """
        context = create_default_context()
        self._params = connection.ConnectionParameters(
            host=_host,
            port=_port,
            virtual_host=_virtual_host,
            credentials=credentials.PlainCredentials(_username, _password),
            ssl_options=SSLOptions(context, _host))
        self._conn = None
        self._channel = None
        self._logger = logging.getLogger(__name__)

    def connect(self):
        """
        :return: None
        """
        if not self._conn or self._conn.is_closed:
            self._conn = BlockingConnection(self._params)
            self._channel = self._conn.channel()
            self._channel.exchange_declare(
                exchange=self.EXCHANGE, exchange_type=self.TYPE, durable=True)

    def _publish(self, _msg):
        """
        :param _msg:
        :return: None
        """
        self._channel.basic_publish(
            exchange=self.EXCHANGE,
            routing_key=self.ROUTING_KEY,
            body=json.dumps(_msg).encode())
        self._logger.debug('message sent: %s', _msg)

    def publish(self, _msg):
        """
        Publish msg, reconnecting if necessary.
        :param _msg:
        :return: None
        """
        try:
            self._publish(_msg)
        except exceptions.ConnectionClosed:
            self._logger.debug('reconnecting to queue')
            self.connect()
            self._publish(_msg)

    def close(self):
        """
        :return: None
        """
        if self._conn and self._conn.is_open:
            self._logger.debug('closing queue connection')
            self._conn.close()


def time_format_elastic_search(_dt, _logger):
    """
    Function takes in a datetime object and returns a YYYY-mm-ddTHH:MM:SS formatted string
    :param _dt: datetime object
    :param _logger: handle to the logger
    :return: string or None
    """
    if type(_dt) not in [datetime]:
        _logger.error('Received unexpected type: {}'.format(type(_dt)))
        return
    return '{}{}Z'.format(_dt.strftime('%Y-%m-%dT%H:%M:%S'), _dt.strftime('%z'))


def time_format(_dt, _logger):
    """
    Function takes in a datetime object and returns a YYYY-mm-ddTHH:MM:SS.fffZ formatted string
    :param _dt: datetime object
    :param _logger: handle to the logger
    :return: string or None
    """
    if type(_dt) not in [datetime]:
        _logger.error('Received unexpected type: {}'.format(type(_dt)))
        return
    return _dt.strftime("'%Y-%m-%d','%H:%M:%S'")


def deconstruct_and_publish_malware_info(_ticket, _rabbit, _logger):
    """
    Deconstructs Malware ticket response into the following data model:
    ticket_id: identified by u_number
    created: identified by sys_created_on, ticket creation date
    malware_name: Extracted from u_info.path
    malware_path: Extracted from u_info.path
    Publishes the above data model to RMQ
    :param _ticket:
    :param _rabbit: RMQ object to publish data
    :param _logger: handle to the logger
    :return:
    """
    _ticket_id = _ticket.get('u_number', '')
    _created = _ticket.get('sys_created_on', '')
    _malware_info = ast.literal_eval(_ticket.get('u_info', []))
    _exclude_pattern = re.compile(r'more files')  # Exclude paths with no useful malware info.

    try:
        # created must be in a format compatible with ElasticSearch
        _created = time_format_elastic_search(datetime.strptime(_created, '%Y-%m-%d %H:%M:%S'), _logger)
        if not _created:
            return

        # Deconstruct malware info from DCU ticket
        for _info in _malware_info:
            _full_path = _info.get('path', '')
            if _full_path and not re.search(_exclude_pattern, _full_path):

                # example: 'rex.backdoor.chaos.001 - /public_html/spot.com/cgi-bin/cs.php'
                _malware = _full_path.split(' - ')

                _malware_name, _malware_path = _malware[0], _malware[-1]

                # Only retrieve filename and one filepath above
                _malware_path = "/".join(_malware_path.split('/')[-2:])

                # Publish data = {ticketId, malware_name, malware_path} to RMQ
                _data = {
                    'ticketId': _ticket_id,
                    'malware_name': _malware_name,
                    'malware_path': _malware_path,
                    'created': _created
                }
                _rabbit.publish(_data)
    except Exception as _e:
        _logger.error('Exception while processing ticketId {}. Error: {}'.format(_ticket_id, _e))


def retrieve_snow_malware_scanner_tickets(_app_settings, _logger):
    """
    :param _app_settings:
    :param _logger: handle to the logger
    :return: list
    """
    _headers = {'Content-Type': 'application/json', 'Accept': 'application/json'}

    _data = []
    try:
        # Get all Malware Scanner tickets from the last run of daily cron
        _timestamp = time_format(datetime.utcnow() - timedelta(days=1), _logger)
        if not _timestamp:
            return _data

        _url = _app_settings.URL.format(timestamp=_timestamp)

        _response = requests.get(_url, auth=(_app_settings.SNOW_USER, _app_settings.SNOW_PASS), headers=_headers)

        if _response.status_code == 200:
            _data = _response.json().get('result', [])
        else:
            _logger.error('Unable to retrieve tickets from SNOW API {}: {}'.format(_response.status_code,
                                                                                   _response.json()))
    except Exception as _e:
        _logger.error('Exception while retrieving tickets from SNOW API {}'.format(_e))
    finally:
        return _data


def setup_logging():
    """
    Sets up logging
    :return: handle to the logger
    """
    try:
        _path = 'logging.yaml'
        _value = os.getenv('LOG_CFG', None)
        if _value:
            _path = _value
        if _path and os.path.exists(_path):
            with open(_path, 'rt') as f:
                _l_config = yaml.safe_load(f.read())
            dictConfig(_l_config)
        else:
            logging.basicConfig(level=logging.INFO)
    except Exception:
        logging.basicConfig(level=logging.INFO)
    finally:
        return logging.getLogger(__name__)


if __name__ == '__main__':
    _logger = setup_logging()
    _logger.info('Starting Malware Scanner stats Retrieval')

    _app_settings = config_by_name[os.getenv('sysenv', 'dev')]()

    # Retrieve Malware Scanner tickets from SNOW API
    _malware_scanner_tickets = retrieve_snow_malware_scanner_tickets(_app_settings, _logger)

    if _malware_scanner_tickets:
        _rabbit = Publisher(
            _host='rmq-dcu.int.godaddy.com',
            _port=5672,
            _virtual_host='grandma',
            _username=os.getenv('BROKER_USER', 'user'),
            _password=os.getenv('BROKER_PASS', 'password'))
        _rabbit.connect()

        # For each ticket in SNOW response, deconstruct into ticketId, ticket creation date and malware_path info
        for _ticket in _malware_scanner_tickets:
            deconstruct_and_publish_malware_info(_ticket, _rabbit, _logger)

    _logger.info('Done Malware Scanner stats Retrieval')
