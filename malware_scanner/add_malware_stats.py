import logging
import os

import yaml
import requests
import ast
import json
import pika

from logging.config import dictConfig
from settings import config_by_name
from datetime import datetime, timedelta


env = os.getenv('sysenv', 'dev')
app_settings = config_by_name[env]()

path = ''
value = os.getenv('LOG_CFG', None)
if value:
    path = value
if os.path.exists(path):
    with open(path, 'rt') as f:
        lconfig = yaml.safe_load(f.read())
    dictConfig(lconfig)
else:
    logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def time_format(dt):
    """
    Function takes in a datetime object and returns a YYYY-mm-dd, HH:MM:SS formatted string
    :param dt: datetime object
    :return: string or None
    """
    if type(dt) not in [datetime]:
        logger.error('Received unexpected type: {}'.format(type(dt)))
        return
    return dt.strftime("'%Y-%m-%d','%H:%M:%S'")


class Publisher:
    EXCHANGE = 'malware-stats'
    TYPE = 'direct'
    ROUTING_KEY = 'malware-stats'

    def __init__(self, host, port, virtual_host, username, password):
        self._params = pika.connection.ConnectionParameters(
            host=host,
            port=port,
            virtual_host=virtual_host,
            credentials=pika.credentials.PlainCredentials(username, password),
            ssl=True)
        self._conn = None
        self._channel = None
        self._logger = logging.getLogger(__name__)

    def connect(self):
        if not self._conn or self._conn.is_closed:
            self._conn = pika.BlockingConnection(self._params)
            self._channel = self._conn.channel()
            self._channel.exchange_declare(
                exchange=self.EXCHANGE, exchange_type=self.TYPE, durable=True)

    def _publish(self, msg):
        self._channel.basic_publish(
            exchange=self.EXCHANGE,
            routing_key=self.ROUTING_KEY,
            body=json.dumps(msg).encode())
        self._logger.debug('message sent: %s', msg)

    def publish(self, msg):
        """Publish msg, reconnecting if necessary."""

        try:
            self._publish(msg)
        except pika.exceptions.ConnectionClosed:
            self._logger.debug('reconnecting to queue')
            self.connect()
            self._publish(msg)

    def close(self):
        if self._conn and self._conn.is_open:
            self._logger.debug('closing queue connection')
            self._conn.close()


def deconstruct_and_publish_malware_info(ticket, rabbit):
    """
    Deconstructs Malware ticket response into the following data model:
    ticket_id: identified by u_number
    malware_name: Extracted from u_info.path
    malware_path: Extracted from u_info.path
    Publishes the above data model to RMQ
    :param ticket:
    :param rabbit: RMQ object to publish data
    :return:
    """
    ticket_id = ticket.get('u_number', '')
    malware_info = ast.literal_eval(ticket.get('u_info', []))

    for info in malware_info:
        full_path = info.get('path', '')
        if full_path:
            malware_name, malware_path = full_path.split(' - ')
            malware_path = "/".join(malware_path.split('/')[-2:])  # Only retrieve filename and one filepath above

            # Publish data = {ticketId, malware_name, malware_path} to RMQ
            data = {'ticketId': ticket_id, 'malware_name': malware_name, 'malware_path': malware_path}
            rabbit.publish(data)


def retrieve_snow_malware_scanner_tickets():
    headers = {"Content-Type": "application/json", "Accept": "application/json"}

    data = []
    try:
        # Get all Malware Scanner tickets from the last run of daily cron
        timestamp = time_format(datetime.utcnow() - timedelta(days=1))
        if not timestamp:
            return data

        url = app_settings.URL.format(timestamp=timestamp)

        response = requests.get(url, auth=(app_settings.SNOW_USER, app_settings.SNOW_PASS), headers=headers)

        if response.status_code == 200:
            data = response.json().get('result', [])
        else:
            logger.error('Unable to retrieve tickets from SNOW API {}: {}'.format(response.status_code,
                                                                                  response.json()))
    except Exception as e:
        logger.error('Exception while retrieving tickets from SNOW API {}'.format(e.message))
    finally:
        return data


if __name__ == '__main__':
    logger.info("Starting Malware Scanner stats Retrieval")

    # Retrieve Malware Scanner tickets from SNOW API
    malware_scanner_tickets = retrieve_snow_malware_scanner_tickets()

    rabbit = Publisher(
        host='rmq-dcu.int.godaddy.com',
        port=5672,
        virtual_host='grandma',
        username=os.getenv('BROKER_USER', 'user'),
        password=os.getenv('BROKER_PASS', 'password'))
    rabbit.connect()

    # For each ticket in SNOW response, deconstruct into TicketId and malware_path info
    for ticket in malware_scanner_tickets:
        deconstruct_and_publish_malware_info(ticket, rabbit)

    logger.info("Done Malware Scanner stats Retrieval")
